
函数屏蔽（name hiding）：

当在子类中定义了与基类函数名字相同的函数后，基类的所有同名函数即被屏蔽（子类中不能再被调用），不论其参数是否相同，是否是虚函数；
其基本理由是为了防止在程序中建立新的子类时从疏远的基类中误继承到重载函数；
可以使用 using Base::BaseFuncName; 语句使基类同名函数在子类中再次可见；



接口继承与实现继承：

1. public继承下，子类总是继承基类的接口；

2. 声明一个pure virtual函数的目的，是让子类只继承函数接口；

    可以为纯虚函数提供定义（默认实现，子类具体实现中可以调用），调用的方式是明确指出其class名称。
    Base *p = new Derived;
    p->Base::PureVirtual();

3. 声明一个impure virtual函数的目的，是让子类继承其接口和缺省实现；

4. 声明non-virtual函数的目的，是让子类继承接口及一个强制性的实现；
    子类中不应该再重新定义此函数；

----------------------------------------------------------------------------------------------------------------

virtual 析构函数：

如果派生类对象经由一个基类指针被删除，而该基类函数为 non-virtual, 其结果未定义：实际执行时通常是派生类对象的派生部分没有被销毁；
Base *p = new Derived;
delete p;
解决办法是将基类的析构函数声明为 virtual;

如果一个类意图不被用作基类，定义一个 virtual 析构函数会使对象创建vtbl而增加体积，降低效率，与C语言不兼容；

STL的所有容器类不含虚函数，不被设计作为基类使用；

pure virtual 析构函数允许，但是仍然需要为其提供定义；

----------------------------------------------------------------------------------------------------------------

派生类对象的基类构造期间，virtua函数没有多态性，即不会下降到派生类阶层：
派生类对象的基类构造期间，对象的类型是基类类型；
派生类对象的基类构造期间，派生类的成员变量尚未初始化；

----------------------------------------------------------------------------------------------------------------

构造函数的动作方式是，最基层基类构造函数最先被调用，然后依次调用其派生类的构造函数；
析构函数的运作方式是，最远层派生的类其析构函数最先被调用，然后是其每一个基类的析构函数被调用；



